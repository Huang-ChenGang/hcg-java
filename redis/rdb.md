## RDB (Redis DataBase) 快照持久化

因为 AOF 记录的是操作命令，而不是实际的数据，所以，用 AOF 方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。
如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用。这当然不是理想的结果。

Redis 提供了另一种持久化方法：内存快照。所谓内存快照，就是指内存中的数据在某一个时刻的状态记录。
这就类似于照片，当你给朋友拍照时，一张照片就能把朋友一瞬间的形象完全记下来。

对 Redis 来说，它实现类似照片记录效果的方式，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。
这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件，其中，RDB 就是 Redis DataBase 的缩写。

和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。

### 给哪些内存数据做快照

Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘中。
给内存的全量数据做快照，把它们全部写入磁盘会花费很多时间。而且，全量数据越多，RDB 文件就越大，往磁盘上写数据的时间开销就越大。

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave：
- save：在主线程中执行，会导致阻塞主线程。
- bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。
通过 bgsave 命令来执行全量快照，既提供了数据的可靠性保证，也避免了对 Redis 的性能影响。

### 快照时数据能修改吗

再回顾一下写时复制机制：
写时复制机制（Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。
其核心思想是，如果有多个调用者（callers）同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，
直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。
这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，
因此多个调用者只是读取操作时可以共享同一份资源。

我们在时刻 t 给内存做快照，假设内存数据量是 4GB，磁盘的写入带宽是 0.2GB/s，简单来说，至少需要 20s（4/0.2 = 20）才能做完。
如果在时刻 t+5s 时，一个还没有被写入磁盘的内存数据 A，被修改成了 A’，那么就会破坏快照的完整性，因为 A’不是时刻 t 时的状态。
因此，和拍照类似，我们在做快照时也不希望数据“动”，也就是不能被修改。

为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），
在执行快照的同时，正常处理写操作。

简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。
bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。
此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。
但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本（键值对 C’）。
然后，主线程在这个数据副本上进行修改。同时，bgsave 子进程可以继续把原来的数据（键值对 C）写入 RDB 文件。

这个操作在实际执行过程中，是子进程复制了主线程的页表，所以通过页表映射，能读到主线程的原始数据，
而当有新数据写入或数据修改时，主线程会把新数据或修改后的数据写到一个新的物理内存地址上，并修改主线程自己的页表映射。
所以，子进程读到的类似于原始数据的一个副本，而主线程也可以正常进行修改。

子进程将数据dump到临时的rdb快照文件中，也就是dump.rdb。完成rdb快照文件的生成之后，会替换掉之前的老快照。

流程图如下：

![RDB时的写操作](https://static001.geekbang.org/resource/image/a2/58/a2e5a3571e200cb771ed8a1cd14d5558.jpg)

这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。
Redis 会使用 bgsave 对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，这就允许主线程同时可以修改数据。

### RDB 和 AOF 结合使用

对于快照来说，所谓“连拍”就是指连续地做快照。
这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。

虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销：
- 一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。
- 另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。
虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。
如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了（所以，在 Redis 中如果有一个 bgsave 在运行，就不会再启动第二个 bgsave 子进程）。

跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握：
- 如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。
- 如果频率太高，又会产生额外开销，

Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。
简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。
这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。
而且，AOF 日志也只用记录两次快照间的操作，等到第二次做全量快照时，就可以清空 AOF 日志，
因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。
也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。
这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势。

关于 AOF 和 RDB 的选择问题：
- 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择。
- 如果允许分钟级别的数据丢失，可以只使用 RDB。
- 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。

### 混合持久化配置

```gitignore
# RDB 配置，每隔900s，有超过1个key发生变化，产生就产生一个dump.rdb文件，后台使用的是 bgsave 命令
save 900 1

# 打开 AOF
appendonly yes
# 设置 AOF 生成的文件名
appendfilename "appendonly.aof"

# 设置 AOF 回写策略，有三种可选：always、everysec、no
appendfsync everysec
# 当 AOF 重写的时候是否允许回写
no-appendfsync-on-rewrite no

# AOF 文件增量满足多少百分比时执行 AOF 重写，和 auto-aof-rewrite-min-size 是并的关系
auto-aof-rewrite-percentage 100
# AOF 文件大小满足多少时执行 AOF 重写，和 auto-aof-rewrite-percentage 是并的关系
auto-aof-rewrite-min-size 64mb

# 开启混合持久化，字面意思是：AOF 使用 RDB 前言
# 开启混合持久化之后，Redis 的 AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头，将增量的以指令的方式 Append 到 AOF。
# 这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。
# 当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。
# Redis 服务在读取 AOF 文件时判断是否包含RDB，它会查看是否以 REDIS 开头；人为的看的话，也可以看到以REDIS开头，RDB的文件也打开也是乱码。
aof-use-rdb-preamble yes
```

### 思考题

问题：

我们使用一个 2 核 CPU、4GB 内存、500GB 磁盘的云主机运行 Redis，Redis 数据库的数据量大小差不多是 2GB，我们使用了 RDB 做持久化保证。
当时 Redis 的运行负载以修改操作为主，写读比例差不多在 8:2 左右，也就是说，如果有 100 个请求，80 个请求执行的是修改操作。
你觉得，在这个场景下，用 RDB 做持久化有什么风险吗？

解答：

产生的风险主要在于 CPU资源 和 内存资源 这2方面：

1. 内存资源风险：Redis fork子进程做RDB持久化，由于写的比例为80%，那么在持久化过程中，“写实复制”会重新分配整个实例80%的内存副本，
大约需要重新分配1.6GB内存空间，这样整个系统的内存使用接近饱和，如果此时父进程又有大量新key写入，很快机器内存就会被吃光，
如果机器开启了Swap机制，那么Redis会有一部分数据被换到磁盘上，当Redis访问这部分在磁盘上的数据时，性能会急剧下降，
已经达不到高性能的标准（可以理解为武功被废）。如果机器没有开启Swap，会直接触发OOM，父子进程会面临被系统kill掉的风险。

2. CPU资源风险：虽然子进程在做RDB持久化，但生成RDB快照过程会消耗大量的CPU资源，虽然Redis处理处理请求是单线程的，
但Redis Server还有其他线程在后台工作，例如AOF每秒刷盘、异步关闭文件描述符这些操作。
由于机器只有2核CPU，这也就意味着父进程占用了超过一半的CPU资源，此时子进程做RDB持久化，可能会产生CPU竞争，
导致的结果就是父进程处理请求延迟增大，子进程生成RDB快照的时间也会变长，整个Redis Server性能下降。