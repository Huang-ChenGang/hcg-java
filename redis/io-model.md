## redis IO模型

解释一下什么是IO模型：
键值数据库网络框架接收到网络包，并按照相应的协议进行解析之后，就可以知道客户端具体想要做的操作，并开始实际的执行相应操作。
此时，我们会遇到一个系统设计上的问题，简单来说，就是网络连接的处理、网络请求的解析，以及数据存取的处理，是用一个线程还是多个线程，
还是多个进程来交互处理呢？该如何进行设计和取舍呢？我们一般把这个问题称为 I/O 模型设计。
不同的 I/O 模型对键值数据库的性能和可扩展性会有不同的影响。

我们知道 redis 的IO模型是单线程，Redis 单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，
这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

### 为什么使用单线程

使用多线程，可以增加系统吞吐率，或是可以增加系统扩展性。
对于一个多线程的系统来说，在有合理的资源分配的情况下，可以增加系统中处理请求操作的资源实体，进而提升系统能够同时处理的请求数，即吞吐率。
但是，通常情况下，在我们采用多线程后，如果没有良好的系统设计，并不会有预想中的效果。
刚开始增加线程数时，系统吞吐率会增加，但是，再进一步增加线程时，系统吞吐率就增长迟缓了，有时甚至还会出现下降的情况。
一个关键的瓶颈在于，系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构。
当有多个线程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证，而这个额外的机制，就会带来额外的开销。
这就是多线程编程模式面临的共享资源的并发访问控制问题。

并发访问控制一直是多线程开发中的一个难点问题，如果没有精细的设计，比如说，只是简单地采用一个粗粒度互斥锁，
就会出现不理想的结果：即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。
而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。
为了避免这些问题，Redis 直接采用了单线程模式。

### redis单线程为什么这么快

一方面，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。
另一方面，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。

先熟悉一下Socket通信基本流程：

![Socket](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b0aca7fa9d6400c87b3afb3603c29c8~tplv-k3u1fbpfcp-watermark.awebp)

服务器端：
1. 创建一个用于监听连接的Socket对像，用指定的端口号和服务器的ip建立一个EndPoint对像。
2. 用socket对像的Bind()方法绑定EndPoint。
3. 用socket对像的Listen()方法设置监听队列，开始监听请求。
4. 接收到客户端的连接，Accept()方法循环等待客户端连接。
5. Receive()方法接收客户端请求。
6. Send()方法发送响应到客户端。
7. 使用完毕，关闭Socket。

客户端：
1. 创建一个用于发送信息的Socket对像，用指定的端口号和服务器的ip建立一个EndPoint对像。
2. 用socket对像的Connect()方法以上面建立的EndPoint对像做为参数，向服务器发出连接请求。
3. 如果连接成功，就用socket对像的Send()方法向服务器发送信息。
4. 用socket对像的Receive()方法接受服务器发来的信息。
5. 使用完毕，关闭Socket。

可以看到在Socket的网络IO中，服务端有潜在的阻塞点：
- Accept()方法循环等待客户端连接：当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，
会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。
- Receive()方法接收客户端请求：当 Redis 通过 receive() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 receive()。
这两个阻塞点可能导致 Redis 整个线程阻塞，无法处理其他客户端请求，效率很低。

Redis 使用 socket 网络模型本身支持的非阻塞模式解决了这两个可能的阻塞问题。

在 socket 模型中，不同操作调用后会返回不同的套接字类型。
socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。
最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字。

针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。
但是，你要注意的是，调用 accept() 时，已经存在监听套接字了。

虽然 Redis 线程可以不用继续等待，Redis使用操作系统内核中的机制（如Linux中的 select/epoll 机制）继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis。

类似的，我们也可以针对已连接套接字设置非阻塞模式：Redis 调用 recv() 后，如果已连接套接字上一直没有数据到达，
Redis 线程同样可以返回处理其他操作。Redis使用操作系统内核中的机制（如Linux中的 select/epoll 机制）继续监听该已连接套接字，并在有数据达到时通知 Redis。

这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis 无法处理实际到达的连接请求或数据。

### 总结

Redis 单线程是指它对网络 IO 和数据读写的操作采用了一个线程，而采用单线程的一个核心原因是避免多线程开发的并发控制问题。
单线程的 Redis 也能获得高性能，跟多路复用的 IO 模型密切相关，因为这避免了 accept() 和 send()/recv() 潜在的网络 IO 操作阻塞点。

Redis单线程处理IO请求还有2个方面的性能瓶颈：
1. 任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。
耗时的操作包括以下几种：
    - 操作bigKey：写入一个bigKey在分配内存时需要消耗更多的时间，同样，删除bigKey释放内存同样会产生耗时。
    - 使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据。
    - 大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长。
    - 淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长。
    - AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能。
    - 主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久。
2. 并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，
只能单线程依次读取客户端的数据，无法利用到CPU多核。

针对问题1，一方面需要业务人员去规避，
一方面Redis在4.0推出了lazy-free机制，把bigKey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。

针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，
当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。