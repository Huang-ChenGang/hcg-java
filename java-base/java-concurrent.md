## Java线程模型
Java创建和销毁线程时会通过JVM调用操作系统，JVM和操作系统的对应关系就是线程模型。
Java线程模型分类：一对一、多对一、多对多
1. 一对一：当前主流Java虚拟机都采用这个模型。
2. 多对一：当一个用户线程阻塞，造成当前的内核线程阻塞，就会阻塞其他用户线程。
3. 多对多：实现起来比较难，但是能够实现更大并发量，GO语言就是采用这个模型。

## Java锁机制
Java锁机制的概念：在多线程并发情况下可能会有多个线程对同一个资源进行争抢，会导致数据不一致的问题。
Java就抽象了一个锁概念，用来对资源进行锁定，保证数据一致性。

在Java中每个对象都拥有一把锁，存放在对象头中，锁里边记录了当前对象被哪个线程所占用。

Java对象构成：对象头、实例对象、填充字节。
1. 对象头：MarkWord和ClassPointer组成。
    MarkWord：存储和当前对象运行时有关的数据，包含HashCode、分代年龄、锁标志等。
    ClassPointer：是一个指针，指向当前对象类型指向方法区中的类型数据。
2. 实例对象
3. 填充字节：保证每个Java对象大小是8Byte的倍数，无用字节。

synchronized关键字原理（优化前）：synchronized会编译成monitorenter和monitorexit两个字节码命令。
资源被monitorenter之后不可被其他线程获取，monitorexit之后才能被其他线程获取。
依赖于操作系统，所以每当挂起或唤醒Java线程都需要切换到内核态，非常重量级。
Java6之后synchronized进行了优化，引入了偏向锁和轻量级锁。

Java锁状态由低到高：无锁、偏向锁、轻量级锁、重量级锁。
锁只能升级不能降级。

当对象的锁为偏向锁时，对象头中存有可以访问这个对象的线程ID，可以理解为这个对象偏爱这个线程，所以叫偏向锁。
当偏向锁对象发现有多个线程竞争时，就会升级为轻量级锁。

当对象锁为轻量级锁时，一个线程想要获取轻量级锁时，会在自己的虚拟机栈中开辟一块空间，叫LockRecord。
虚拟机栈是线程私有的，不存在同步问题。
LockRecord中存放的是对象头中的MarkWord副本以及Owner指针。
当线程用CAS获取到轻量级锁之后，会把对象头中的MarkWord复制一份到自己的LockRecord中，然后将Owner指针指向对象锁。
对象头中的MarkWord前30位就会生成一个指针，指向持有这个对象锁的线程的LockRecord。
这样对象和线程就会相互知道对方的存在，就会形成一个绑定的关系。
其他线程再想要获得这个轻量级锁就会进入自旋等待，当对象发现有多个线程自旋时，就会升级为重量级锁。


高并发集合问题主要为第三代线程安全集合类，位于 java.util.concurrent.* 下，
ConcurrentHashMap等，
主要是CAS和AQS。

## CAS
CAS是无锁方式竞争资源的方法。
CAS在操作系统中通过一条指令来实现，所以能够保证原子性。

## AQS