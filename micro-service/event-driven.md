## 微服务以及分布式数据管理中存在的问题

单体应用通常使用单个关系型数据库，由此带来的好处是应用能够使用ACID事务：
- A：atomicity：原子性：原子粒度的更改。
- C：consistency：一致性：数据库的状态始终保持一致。
- I：isolation：隔离性：并发执行的事务显示为串行执行。
- D：durability：持久性：事务一旦提交就不会被撤销。
如此，应用能够简单地开始事务、更改（插入、修改、删除）、以及提交事务。

然而，微服务架构中的数据访问变得复杂许多。每个微服务都拥有自己的数据库，专门用于该微服务访问，仅对外提供API访问。
这种数据封装保证了微服务间的松耦合，并且可以独立更新。但是如果多个微服务间有数据交互，架构更新就会变得复杂很多。
会耗费时间、也需要所有服务的协调更新。

微服务确实带来了服务间的松耦合、更好的性能和扩展性。但是也给数据管理带来了挑战：
- 每个服务有自己的数据库，如何实现业务逻辑，保持多个服务的数据一致性。
- 如何实现检索多个服务数据的查询。

## 事件驱动架构

事件驱动架构：当有显著事件发生时，譬如更新业务实体，某个微服务会发布事件，其他微服务订阅这些事件；
当某一微服务接收到事件就可以更新自己的业务实体，实现更多事件被发布。

事件驱动架构使用事件来实现跨多个服务的业务逻辑。
事务由一系列步骤组成，每一步都有一个微服务更新业务实体，然后发布触发下一步的事件。

事件驱动架构用来解决微服务数据管理问题，也就是说可以用来做分布式事务。
这种模式提供最终一致性，这种事务模型也被称作BASE模型。BASE模型定义可参考[分布式事务](/distributed/distributed-transaction.md)。

事件驱动架构要求处理事件的一方要解决幂等性问题。

### 事件驱动架构带来的问题

事件驱动架构带来的问题就是如何将业务逻辑处理和发布事件做到原子化。

### 解决方案一：使用本地事务发布事件

该解决方案是在本地服务中维护一个本地事件表。每次涉及到发布事件的业务，在业务逻辑处理成功后就插入一个事件到时间表。
业务处理和插入事件表是同一个事务里的，就保证了原子性。然后另启一个线程（可以设置为守护线程）来定时循环获取未发布的事件并发布。

优点：保证每个需要发布事件的地方都有事件发布。

缺点：发布事件和业务逻辑耦合、必须牢记要发布事件（发布事件线程）。

### 解决方案二：挖掘数据库事务日志

该解决方案是由额外的线程或进程通过挖掘数据库事务或提交日志来发布事件。
应用更新数据库，数据库的事务日志记录这些变更。事务日志挖掘线程或进程读取这些日志，并把事件发布到消息代理。

优点：将发布事件和业务逻辑分离，简化了应用。

缺点：需要实现单独的日志挖掘线程或进程，有开发难度。

### 解决方案三：使用事件源

该解决方式是当业务状态发生变化时，不去保存业务表，而是直接发布状态变更事件。通过事件监听来更改业务实体。

优点：有状态变化就会发布事件。

缺点：
- 事件发布失败则整个业务逻辑失败。
- 业务变更有可能不只更改状态，更改其他字段的时候还是需要更新业务表。