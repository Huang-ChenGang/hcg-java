## 分布式事务

分布式对应的是单体架构。早起的架构里是在一个应用里进行ACID。
但是随着业务的复杂度提高，逐渐演变为了现在的分布式服务，服务间互相协作，每个服务负责不同的业务。
这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务。
在Java里可以简言之：跨JVM进程产生分布式事务。

协调者和参与者说明：在分布式架构下，每个节点只知晓自己操作的失败或者成功，无法得知其他节点的状态。
当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，
并指示它们是否要把操作结果进行真正的提交或者回滚。

## CAP原则

### C：consistency：一致性

指强一致性，在写操作完成后开始的任何读操作都必须返回该值，或者后续写操作的结果。
也就是说，在一致性系统中，一旦客户端将值写入任何一台服务器并获得响应，那么之后client从其他任何服务器读取的都是刚写入的数据。
一致性保证了不管向哪台服务器写入数据，其他的服务器能实时同步数据。

### A：availability：可用性

可用性（高可用）是指：每次向未崩溃的节点发送请求，总能保证收到响应数据（允许不是最新数据）。

### P：partition tolerance：分区容忍性

分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

CAP原则又叫CAP定理，指的是在一个分布式系统中，不可能同时满足CAP三点。
分布式系统注定要满足P，所以只能是CP或AP，也就是要在一致性和可用性中做选择。

## BASE理论

BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，
理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，
采用适当的方式来使系统达到最终一致性。

### BA：basic available：基本可用

整个系统在某些不可抗力的情况下，仍然能够保证“可用性”，
即一定时间内仍然能够返回一个明确的结果。这里是属于基本可用。

基本可用和高可用的区别：
- “一定时间”可以适当延长 当举行大促（比如秒杀）时，响应时间可以适当延长。
- 给部分用户返回一个降级页面 给部分用户直接返回一个降级页面，从而缓解服务器压力。但要注意，返回降级页面仍然是返回明确结果。

### S：soft state：柔性状态

称为柔性状态，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，
即允许系统不同节点的数据副本之间进行数据同步的过程存在延时。

### E：eventual consistency：最终一致性

同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。

## 2PC：two-phase commit：二阶段提交

二阶段提交是常用的分布式事务解决方案，即将事务的提交过程分为两个阶段来进行处理。

两个阶段分别为：
- 准备阶段
- 提交阶段

参与的角色：
- 事务协调者（事务管理器）：事务的发起者
- 事务参与者（资源管理器）：事务的执行者

### 准备阶段

这是两阶段的第一段，这一阶段只是准备阶段，由事务的协调者发起询问参与者是否可以提交事务，
但是这一阶段并未提交事务，流程如下：
1. 协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复。
2. 各参与者执行事务操作，将提交(redo)和撤销(undo)信息记入事务日志中（但不提交事务）。
3. 如参与者执行成功，给协调者反馈同意，否则反馈中止。

### 提交阶段

这一段阶段属于2PC的第二阶段（提交 执行阶段），协调者发起正式提交事务的请求，
当所有参与者都回复同意时，则意味着完成事务，流程如下：
1. 协调者节点向所有参与者节点发出正式提交的请求。
2. 参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送完成消息。
4. 协调者节点收到所有参与者节点反馈的完成消息后，完成事务。

但是如果任意一个参与者节点在第一阶段返回的消息为终止，
或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时，
那么这个事务将会被回滚，回滚的流程如下：
1. 协调者节点向所有参与者节点发出回滚操作的请求。
2. 参与者节点利用阶段一写入的撤销(undo)信息执行回滚，并释放在整个事务期间内占用的资源。
3. 参与者节点向协调者节点发送回滚完成消息。
4. 协调者节点受到所有参与者节点反馈的回滚完成消息后，取消事务。

不管最后结果如何，第二阶段都会结束当前事务。

### 2PC缺点

- 性能问题：执行过程中，所有参与节点都是事务阻塞型的。
当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
- 可靠性问题：参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。
协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。
- 实现复杂：牺牲了可用性，对性能影响较大，不适合高并发高性能场景。

### 2PC优点

尽量保证了数据的强一致（其实也不能100%保证强一致）。

## 3PC：三阶段提交

三阶段提交协议，是二阶段提交协议的改进版本，三阶段提交有两个改动点：
- 在协调者和参与者中都引入超时机制。
- 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，
这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。

### 阶段一：CanCommit阶段

3PC的CanCommit阶段其实和2PC的准备阶段很像。
协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。
- 事务询问：协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。
- 响应反馈：参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。

### 阶段二：阶段二：PreCommit阶段

协调者根据参与者的反应情况来决定是否可以进行事务的PreCommit操作。根据响应情况，有以下两种可能：

- 假如所有参与者均反馈 yes，协调者预执行事务。
    1. 发送预提交请求 ：协调者向参与者发送PreCommit请求，并进入准备阶段
    2. 事务预提交 ：参与者接收到PreCommit请求后，会执行事务操作，并将撤销(undo)和提交(redo)信息记录到事务日志中（但不提交事务）
    3. 响应反馈 ：如果参与者成功的执行了事务操作，则返回完成响应，同时开始等待最终指令。
    
- 假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。
    1. 发送中断请求 ：协调者向所有参与者发送abort请求。
    2. 中断事务 ：参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。
    
### 阶段三：doCommit阶段

进入阶段 3 后，无论协调者出现问题，或者协调者与参与者网络出现问题，
都会导致参与者无法接收到协调者发出的 do Commit 请求或 abort 请求。
此时，参与者都会在等待超时之后，继续执行事务提交。

该阶段进行真正的事务提交，也可以分为以下两种情况：
- 执行提交
    1. 发送提交请求：协调接收到参与者发送的完成响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。
    2. 事务提交：参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
    3. 响应反馈：事务提交完之后，向协调者发送完成响应。
    4. 完成事务：协调者接收到所有参与者的ack响应之后，完成事务。
- 中断事务：任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务
    1. 发送中断请求：如果协调者处于工作状态，向所有参与者发出 abort 请求。
    2. 事务回滚：参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
    3. 反馈结果：参与者完成事务回滚之后，向协调者反馈完成消息。
    4. 中断事务：协调者接收到参与者反馈的完成消息之后，执行事务的中断。
    
### 3PC优点

相比二阶段提交，三阶段提交降低了阻塞范围，在等待超时后协调者或参与者会中断事务。
避免了协调者单点问题，阶段 3 中协调者出现问题时，参与者会继续提交事务。

### 3PC缺点

数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 doCommit 指令时，
此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。

## TCC(事务补偿)

TCC（Try Confirm Cancel）方案是一种应用层面侵入业务的两阶段提交。
是目前最火的一种柔性事务方案，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。

TCC分为两个阶段，分别如下：
- 第一阶段：Try（尝试），主要是对业务系统做检测及资源预留 (加锁，锁住资源)。
- 第二阶段：本阶段根据第一阶段的结果，决定是执行confirm还是cancel。
    1. Confirm（确认）：执行真正的业务（执行业务，释放锁）。
    2. Cancel（取消）：是预留资源的取消（出问题，释放锁）。
    
### Try阶段

TCC 机制中的 Try 仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：
- 完成所有业务检查( 一致性 ) 。
- 预留必须业务资源( 准隔离性 ) 。
- Try 尝试执行业务。

### Confirm/Cancel阶段

根据 Try 阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。
Confirm 和 Cancel 操作满足幂等性，如果 Confirm 或 Cancel 操作执行失败，将会不断重试直到执行完成。

Confirm：当 Try 阶段服务全部正常执行，执行确认业务逻辑操作。
这里使用的资源一定是 Try 阶段预留的业务资源。在 TCC 事务机制中认为，如果在 Try 阶段能正常的预留资源，那 Confirm 一定能完整正确的提交。
Confirm 阶段也可以看成是对 Try 阶段的一个补充，Try+Confirm 一起组成了一个完整的业务逻辑。

Cancel：当 Try 阶段存在服务执行失败， 进入 Cancel 阶段。
Cancel 取消执行，释放 Try 阶段预留的业务资源。

### 最终一致性保证

- TCC 事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。
因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销。
- Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。也就是说只要Try成功，Confirm一定成功（TCC设计之初的定义） 。
- Confirm与Cancel如果失败，由TCC框架进行重试补偿。
- 存在极低概率在CC环节彻底失败，则需要定时任务或人工介入。

### TCC优点

- 性能提升：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。
- 数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。
- 可靠性：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。

### TCC缺点

TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。